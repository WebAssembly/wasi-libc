// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
#include "wasi/preview2.h"


__attribute__((__import_module__("wasi:cli/environment@0.2.0-rc-2023-12-05"), __import_name__("get-environment")))
extern void __wasm_import_environment_get_environment(int32_t);

__attribute__((__import_module__("wasi:cli/environment@0.2.0-rc-2023-12-05"), __import_name__("get-arguments")))
extern void __wasm_import_environment_get_arguments(int32_t);

__attribute__((__import_module__("wasi:cli/environment@0.2.0-rc-2023-12-05"), __import_name__("initial-cwd")))
extern void __wasm_import_environment_initial_cwd(int32_t);

__attribute__((__import_module__("wasi:cli/exit@0.2.0-rc-2023-12-05"), __import_name__("exit")))
extern void __wasm_import_exit_exit(int32_t);

__attribute__((__import_module__("wasi:io/error@0.2.0-rc-2023-11-10"), __import_name__("[method]error.to-debug-string")))
extern void __wasm_import_io_error_method_error_to_debug_string(int32_t, int32_t);

__attribute__((__import_module__("wasi:io/poll@0.2.0-rc-2023-11-10"), __import_name__("[method]pollable.ready")))
extern int32_t __wasm_import_poll_method_pollable_ready(int32_t);

__attribute__((__import_module__("wasi:io/poll@0.2.0-rc-2023-11-10"), __import_name__("[method]pollable.block")))
extern void __wasm_import_poll_method_pollable_block(int32_t);

__attribute__((__import_module__("wasi:io/poll@0.2.0-rc-2023-11-10"), __import_name__("poll")))
extern void __wasm_import_poll_poll(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]input-stream.read")))
extern void __wasm_import_streams_method_input_stream_read(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]input-stream.blocking-read")))
extern void __wasm_import_streams_method_input_stream_blocking_read(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]input-stream.skip")))
extern void __wasm_import_streams_method_input_stream_skip(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]input-stream.blocking-skip")))
extern void __wasm_import_streams_method_input_stream_blocking_skip(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]input-stream.subscribe")))
extern int32_t __wasm_import_streams_method_input_stream_subscribe(int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.check-write")))
extern void __wasm_import_streams_method_output_stream_check_write(int32_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.write")))
extern void __wasm_import_streams_method_output_stream_write(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.blocking-write-and-flush")))
extern void __wasm_import_streams_method_output_stream_blocking_write_and_flush(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.flush")))
extern void __wasm_import_streams_method_output_stream_flush(int32_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.blocking-flush")))
extern void __wasm_import_streams_method_output_stream_blocking_flush(int32_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.subscribe")))
extern int32_t __wasm_import_streams_method_output_stream_subscribe(int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.write-zeroes")))
extern void __wasm_import_streams_method_output_stream_write_zeroes(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.blocking-write-zeroes-and-flush")))
extern void __wasm_import_streams_method_output_stream_blocking_write_zeroes_and_flush(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.splice")))
extern void __wasm_import_streams_method_output_stream_splice(int32_t, int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[method]output-stream.blocking-splice")))
extern void __wasm_import_streams_method_output_stream_blocking_splice(int32_t, int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:cli/stdin@0.2.0-rc-2023-12-05"), __import_name__("get-stdin")))
extern int32_t __wasm_import_stdin_get_stdin(void);

__attribute__((__import_module__("wasi:cli/stdout@0.2.0-rc-2023-12-05"), __import_name__("get-stdout")))
extern int32_t __wasm_import_stdout_get_stdout(void);

__attribute__((__import_module__("wasi:cli/stderr@0.2.0-rc-2023-12-05"), __import_name__("get-stderr")))
extern int32_t __wasm_import_stderr_get_stderr(void);

__attribute__((__import_module__("wasi:cli/terminal-stdin@0.2.0-rc-2023-12-05"), __import_name__("get-terminal-stdin")))
extern void __wasm_import_terminal_stdin_get_terminal_stdin(int32_t);

__attribute__((__import_module__("wasi:cli/terminal-stdout@0.2.0-rc-2023-12-05"), __import_name__("get-terminal-stdout")))
extern void __wasm_import_terminal_stdout_get_terminal_stdout(int32_t);

__attribute__((__import_module__("wasi:cli/terminal-stderr@0.2.0-rc-2023-12-05"), __import_name__("get-terminal-stderr")))
extern void __wasm_import_terminal_stderr_get_terminal_stderr(int32_t);

__attribute__((__import_module__("wasi:clocks/monotonic-clock@0.2.0-rc-2023-11-10"), __import_name__("now")))
extern int64_t __wasm_import_monotonic_clock_now(void);

__attribute__((__import_module__("wasi:clocks/monotonic-clock@0.2.0-rc-2023-11-10"), __import_name__("resolution")))
extern int64_t __wasm_import_monotonic_clock_resolution(void);

__attribute__((__import_module__("wasi:clocks/monotonic-clock@0.2.0-rc-2023-11-10"), __import_name__("subscribe-instant")))
extern int32_t __wasm_import_monotonic_clock_subscribe_instant(int64_t);

__attribute__((__import_module__("wasi:clocks/monotonic-clock@0.2.0-rc-2023-11-10"), __import_name__("subscribe-duration")))
extern int32_t __wasm_import_monotonic_clock_subscribe_duration(int64_t);

__attribute__((__import_module__("wasi:clocks/wall-clock@0.2.0-rc-2023-11-10"), __import_name__("now")))
extern void __wasm_import_wall_clock_now(int32_t);

__attribute__((__import_module__("wasi:clocks/wall-clock@0.2.0-rc-2023-11-10"), __import_name__("resolution")))
extern void __wasm_import_wall_clock_resolution(int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.read-via-stream")))
extern void __wasm_import_filesystem_method_descriptor_read_via_stream(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.write-via-stream")))
extern void __wasm_import_filesystem_method_descriptor_write_via_stream(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.append-via-stream")))
extern void __wasm_import_filesystem_method_descriptor_append_via_stream(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.advise")))
extern void __wasm_import_filesystem_method_descriptor_advise(int32_t, int64_t, int64_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.sync-data")))
extern void __wasm_import_filesystem_method_descriptor_sync_data(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.get-flags")))
extern void __wasm_import_filesystem_method_descriptor_get_flags(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.get-type")))
extern void __wasm_import_filesystem_method_descriptor_get_type(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.set-size")))
extern void __wasm_import_filesystem_method_descriptor_set_size(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.set-times")))
extern void __wasm_import_filesystem_method_descriptor_set_times(int32_t, int32_t, int64_t, int32_t, int32_t, int64_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.read")))
extern void __wasm_import_filesystem_method_descriptor_read(int32_t, int64_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.write")))
extern void __wasm_import_filesystem_method_descriptor_write(int32_t, int32_t, int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.read-directory")))
extern void __wasm_import_filesystem_method_descriptor_read_directory(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.sync")))
extern void __wasm_import_filesystem_method_descriptor_sync(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.create-directory-at")))
extern void __wasm_import_filesystem_method_descriptor_create_directory_at(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.stat")))
extern void __wasm_import_filesystem_method_descriptor_stat(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.stat-at")))
extern void __wasm_import_filesystem_method_descriptor_stat_at(int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.set-times-at")))
extern void __wasm_import_filesystem_method_descriptor_set_times_at(int32_t, int32_t, int32_t, int32_t, int32_t, int64_t, int32_t, int32_t, int64_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.link-at")))
extern void __wasm_import_filesystem_method_descriptor_link_at(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.open-at")))
extern void __wasm_import_filesystem_method_descriptor_open_at(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.readlink-at")))
extern void __wasm_import_filesystem_method_descriptor_readlink_at(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.remove-directory-at")))
extern void __wasm_import_filesystem_method_descriptor_remove_directory_at(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.rename-at")))
extern void __wasm_import_filesystem_method_descriptor_rename_at(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.symlink-at")))
extern void __wasm_import_filesystem_method_descriptor_symlink_at(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.unlink-file-at")))
extern void __wasm_import_filesystem_method_descriptor_unlink_file_at(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.is-same-object")))
extern int32_t __wasm_import_filesystem_method_descriptor_is_same_object(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.metadata-hash")))
extern void __wasm_import_filesystem_method_descriptor_metadata_hash(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]descriptor.metadata-hash-at")))
extern void __wasm_import_filesystem_method_descriptor_metadata_hash_at(int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[method]directory-entry-stream.read-directory-entry")))
extern void __wasm_import_filesystem_method_directory_entry_stream_read_directory_entry(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("filesystem-error-code")))
extern void __wasm_import_filesystem_filesystem_error_code(int32_t, int32_t);

__attribute__((__import_module__("wasi:filesystem/preopens@0.2.0-rc-2023-11-10"), __import_name__("get-directories")))
extern void __wasm_import_filesystem_preopens_get_directories(int32_t);

__attribute__((__import_module__("wasi:sockets/instance-network@0.2.0-rc-2023-11-10"), __import_name__("instance-network")))
extern int32_t __wasm_import_instance_network_instance_network(void);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.start-bind")))
extern void __wasm_import_udp_method_udp_socket_start_bind(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.finish-bind")))
extern void __wasm_import_udp_method_udp_socket_finish_bind(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.stream")))
extern void __wasm_import_udp_method_udp_socket_stream(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.local-address")))
extern void __wasm_import_udp_method_udp_socket_local_address(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.remote-address")))
extern void __wasm_import_udp_method_udp_socket_remote_address(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.address-family")))
extern int32_t __wasm_import_udp_method_udp_socket_address_family(int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.ipv6-only")))
extern void __wasm_import_udp_method_udp_socket_ipv6_only(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.set-ipv6-only")))
extern void __wasm_import_udp_method_udp_socket_set_ipv6_only(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.unicast-hop-limit")))
extern void __wasm_import_udp_method_udp_socket_unicast_hop_limit(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.set-unicast-hop-limit")))
extern void __wasm_import_udp_method_udp_socket_set_unicast_hop_limit(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.receive-buffer-size")))
extern void __wasm_import_udp_method_udp_socket_receive_buffer_size(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.set-receive-buffer-size")))
extern void __wasm_import_udp_method_udp_socket_set_receive_buffer_size(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.send-buffer-size")))
extern void __wasm_import_udp_method_udp_socket_send_buffer_size(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.set-send-buffer-size")))
extern void __wasm_import_udp_method_udp_socket_set_send_buffer_size(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]udp-socket.subscribe")))
extern int32_t __wasm_import_udp_method_udp_socket_subscribe(int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]incoming-datagram-stream.receive")))
extern void __wasm_import_udp_method_incoming_datagram_stream_receive(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]incoming-datagram-stream.subscribe")))
extern int32_t __wasm_import_udp_method_incoming_datagram_stream_subscribe(int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]outgoing-datagram-stream.check-send")))
extern void __wasm_import_udp_method_outgoing_datagram_stream_check_send(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]outgoing-datagram-stream.send")))
extern void __wasm_import_udp_method_outgoing_datagram_stream_send(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[method]outgoing-datagram-stream.subscribe")))
extern int32_t __wasm_import_udp_method_outgoing_datagram_stream_subscribe(int32_t);

__attribute__((__import_module__("wasi:sockets/udp-create-socket@0.2.0-rc-2023-11-10"), __import_name__("create-udp-socket")))
extern void __wasm_import_udp_create_socket_create_udp_socket(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.start-bind")))
extern void __wasm_import_tcp_method_tcp_socket_start_bind(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.finish-bind")))
extern void __wasm_import_tcp_method_tcp_socket_finish_bind(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.start-connect")))
extern void __wasm_import_tcp_method_tcp_socket_start_connect(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.finish-connect")))
extern void __wasm_import_tcp_method_tcp_socket_finish_connect(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.start-listen")))
extern void __wasm_import_tcp_method_tcp_socket_start_listen(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.finish-listen")))
extern void __wasm_import_tcp_method_tcp_socket_finish_listen(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.accept")))
extern void __wasm_import_tcp_method_tcp_socket_accept(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.local-address")))
extern void __wasm_import_tcp_method_tcp_socket_local_address(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.remote-address")))
extern void __wasm_import_tcp_method_tcp_socket_remote_address(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.is-listening")))
extern int32_t __wasm_import_tcp_method_tcp_socket_is_listening(int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.address-family")))
extern int32_t __wasm_import_tcp_method_tcp_socket_address_family(int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.ipv6-only")))
extern void __wasm_import_tcp_method_tcp_socket_ipv6_only(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-ipv6-only")))
extern void __wasm_import_tcp_method_tcp_socket_set_ipv6_only(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-listen-backlog-size")))
extern void __wasm_import_tcp_method_tcp_socket_set_listen_backlog_size(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.keep-alive-enabled")))
extern void __wasm_import_tcp_method_tcp_socket_keep_alive_enabled(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-keep-alive-enabled")))
extern void __wasm_import_tcp_method_tcp_socket_set_keep_alive_enabled(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.keep-alive-idle-time")))
extern void __wasm_import_tcp_method_tcp_socket_keep_alive_idle_time(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-keep-alive-idle-time")))
extern void __wasm_import_tcp_method_tcp_socket_set_keep_alive_idle_time(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.keep-alive-interval")))
extern void __wasm_import_tcp_method_tcp_socket_keep_alive_interval(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-keep-alive-interval")))
extern void __wasm_import_tcp_method_tcp_socket_set_keep_alive_interval(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.keep-alive-count")))
extern void __wasm_import_tcp_method_tcp_socket_keep_alive_count(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-keep-alive-count")))
extern void __wasm_import_tcp_method_tcp_socket_set_keep_alive_count(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.hop-limit")))
extern void __wasm_import_tcp_method_tcp_socket_hop_limit(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-hop-limit")))
extern void __wasm_import_tcp_method_tcp_socket_set_hop_limit(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.receive-buffer-size")))
extern void __wasm_import_tcp_method_tcp_socket_receive_buffer_size(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-receive-buffer-size")))
extern void __wasm_import_tcp_method_tcp_socket_set_receive_buffer_size(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.send-buffer-size")))
extern void __wasm_import_tcp_method_tcp_socket_send_buffer_size(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.set-send-buffer-size")))
extern void __wasm_import_tcp_method_tcp_socket_set_send_buffer_size(int32_t, int64_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.subscribe")))
extern int32_t __wasm_import_tcp_method_tcp_socket_subscribe(int32_t);

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[method]tcp-socket.shutdown")))
extern void __wasm_import_tcp_method_tcp_socket_shutdown(int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/tcp-create-socket@0.2.0-rc-2023-11-10"), __import_name__("create-tcp-socket")))
extern void __wasm_import_tcp_create_socket_create_tcp_socket(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/ip-name-lookup@0.2.0-rc-2023-11-10"), __import_name__("resolve-addresses")))
extern void __wasm_import_ip_name_lookup_resolve_addresses(int32_t, int32_t, int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/ip-name-lookup@0.2.0-rc-2023-11-10"), __import_name__("[method]resolve-address-stream.resolve-next-address")))
extern void __wasm_import_ip_name_lookup_method_resolve_address_stream_resolve_next_address(int32_t, int32_t);

__attribute__((__import_module__("wasi:sockets/ip-name-lookup@0.2.0-rc-2023-11-10"), __import_name__("[method]resolve-address-stream.subscribe")))
extern int32_t __wasm_import_ip_name_lookup_method_resolve_address_stream_subscribe(int32_t);

__attribute__((__import_module__("wasi:random/random@0.2.0-rc-2023-11-10"), __import_name__("get-random-bytes")))
extern void __wasm_import_random_get_random_bytes(int64_t, int32_t);

__attribute__((__import_module__("wasi:random/random@0.2.0-rc-2023-11-10"), __import_name__("get-random-u64")))
extern int64_t __wasm_import_random_get_random_u64(void);

__attribute__((__import_module__("wasi:random/insecure@0.2.0-rc-2023-11-10"), __import_name__("get-insecure-random-bytes")))
extern void __wasm_import_random_insecure_get_insecure_random_bytes(int64_t, int32_t);

__attribute__((__import_module__("wasi:random/insecure@0.2.0-rc-2023-11-10"), __import_name__("get-insecure-random-u64")))
extern int64_t __wasm_import_random_insecure_get_insecure_random_u64(void);

__attribute__((__import_module__("wasi:random/insecure-seed@0.2.0-rc-2023-11-10"), __import_name__("insecure-seed")))
extern void __wasm_import_random_insecure_seed_insecure_seed(int32_t);

__attribute__((__weak__, __export_name__("cabi_realloc")))
void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  (void) old_size;
  if (new_size == 0) return (void*) align;
  void *ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}

// Helper Functions

void preview2_tuple2_string_string_free(preview2_tuple2_string_string_t *ptr) {
  preview2_string_free(&ptr->f0);
  preview2_string_free(&ptr->f1);
}

void preview2_list_tuple2_string_string_free(preview2_list_tuple2_string_string_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
    preview2_tuple2_string_string_free(&ptr->ptr[i]);
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void preview2_list_string_free(preview2_list_string_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
    preview2_string_free(&ptr->ptr[i]);
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void preview2_option_string_free(preview2_option_string_t *ptr) {
  if (ptr->is_some) {
    preview2_string_free(&ptr->val);
  }
}

void exit_result_void_void_free(exit_result_void_void_t *ptr) {
  if (!ptr->is_err) {
  }
}

__attribute__((__import_module__("wasi:io/error@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]error")))
extern void __wasm_import_io_error_error_drop(int32_t handle);

void io_error_error_drop_own(io_error_own_error_t handle) {
  __wasm_import_io_error_error_drop(handle.__handle);
}

void io_error_error_drop_borrow(io_error_borrow_error_t handle) {
  __wasm_import_io_error_error_drop(handle.__handle);
}

io_error_borrow_error_t io_error_borrow_error(io_error_own_error_t arg) {
  return (io_error_borrow_error_t) { arg.__handle };
}

__attribute__((__import_module__("wasi:io/poll@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]pollable")))
extern void __wasm_import_poll_pollable_drop(int32_t handle);

void poll_pollable_drop_own(poll_own_pollable_t handle) {
  __wasm_import_poll_pollable_drop(handle.__handle);
}

void poll_pollable_drop_borrow(poll_borrow_pollable_t handle) {
  __wasm_import_poll_pollable_drop(handle.__handle);
}

poll_borrow_pollable_t poll_borrow_pollable(poll_own_pollable_t arg) {
  return (poll_borrow_pollable_t) { arg.__handle };
}

void poll_list_borrow_pollable_free(poll_list_borrow_pollable_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void preview2_list_u32_free(preview2_list_u32_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void streams_stream_error_free(streams_stream_error_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      break;
    }
  }
}

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]input-stream")))
extern void __wasm_import_streams_input_stream_drop(int32_t handle);

void streams_input_stream_drop_own(streams_own_input_stream_t handle) {
  __wasm_import_streams_input_stream_drop(handle.__handle);
}

void streams_input_stream_drop_borrow(streams_borrow_input_stream_t handle) {
  __wasm_import_streams_input_stream_drop(handle.__handle);
}

streams_borrow_input_stream_t streams_borrow_input_stream(streams_own_input_stream_t arg) {
  return (streams_borrow_input_stream_t) { arg.__handle };
}

__attribute__((__import_module__("wasi:io/streams@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]output-stream")))
extern void __wasm_import_streams_output_stream_drop(int32_t handle);

void streams_output_stream_drop_own(streams_own_output_stream_t handle) {
  __wasm_import_streams_output_stream_drop(handle.__handle);
}

void streams_output_stream_drop_borrow(streams_borrow_output_stream_t handle) {
  __wasm_import_streams_output_stream_drop(handle.__handle);
}

streams_borrow_output_stream_t streams_borrow_output_stream(streams_own_output_stream_t arg) {
  return (streams_borrow_output_stream_t) { arg.__handle };
}

void preview2_list_u8_free(preview2_list_u8_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void streams_result_list_u8_stream_error_free(streams_result_list_u8_stream_error_t *ptr) {
  if (!ptr->is_err) {
    preview2_list_u8_free(&ptr->val.ok);
  } else {
    streams_stream_error_free(&ptr->val.err);
  }
}

void streams_result_u64_stream_error_free(streams_result_u64_stream_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
    streams_stream_error_free(&ptr->val.err);
  }
}

void streams_result_void_stream_error_free(streams_result_void_stream_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
    streams_stream_error_free(&ptr->val.err);
  }
}

__attribute__((__import_module__("wasi:cli/terminal-input@0.2.0-rc-2023-12-05"), __import_name__("[resource-drop]terminal-input")))
extern void __wasm_import_terminal_input_terminal_input_drop(int32_t handle);

void terminal_input_terminal_input_drop_own(terminal_input_own_terminal_input_t handle) {
  __wasm_import_terminal_input_terminal_input_drop(handle.__handle);
}

void terminal_input_terminal_input_drop_borrow(terminal_input_borrow_terminal_input_t handle) {
  __wasm_import_terminal_input_terminal_input_drop(handle.__handle);
}

terminal_input_borrow_terminal_input_t terminal_input_borrow_terminal_input(terminal_input_own_terminal_input_t arg) {
  return (terminal_input_borrow_terminal_input_t) { arg.__handle };
}

__attribute__((__import_module__("wasi:cli/terminal-output@0.2.0-rc-2023-12-05"), __import_name__("[resource-drop]terminal-output")))
extern void __wasm_import_terminal_output_terminal_output_drop(int32_t handle);

void terminal_output_terminal_output_drop_own(terminal_output_own_terminal_output_t handle) {
  __wasm_import_terminal_output_terminal_output_drop(handle.__handle);
}

void terminal_output_terminal_output_drop_borrow(terminal_output_borrow_terminal_output_t handle) {
  __wasm_import_terminal_output_terminal_output_drop(handle.__handle);
}

terminal_output_borrow_terminal_output_t terminal_output_borrow_terminal_output(terminal_output_own_terminal_output_t arg) {
  return (terminal_output_borrow_terminal_output_t) { arg.__handle };
}

void terminal_stdin_option_own_terminal_input_free(terminal_stdin_option_own_terminal_input_t *ptr) {
  if (ptr->is_some) {
  }
}

void terminal_stdout_option_own_terminal_output_free(terminal_stdout_option_own_terminal_output_t *ptr) {
  if (ptr->is_some) {
  }
}

void terminal_stderr_option_own_terminal_output_free(terminal_stderr_option_own_terminal_output_t *ptr) {
  if (ptr->is_some) {
  }
}

void filesystem_option_datetime_free(filesystem_option_datetime_t *ptr) {
  if (ptr->is_some) {
  }
}

void filesystem_descriptor_stat_free(filesystem_descriptor_stat_t *ptr) {
  filesystem_option_datetime_free(&ptr->data_access_timestamp);
  filesystem_option_datetime_free(&ptr->data_modification_timestamp);
  filesystem_option_datetime_free(&ptr->status_change_timestamp);
}

void filesystem_new_timestamp_free(filesystem_new_timestamp_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 2: {
      break;
    }
  }
}

void filesystem_directory_entry_free(filesystem_directory_entry_t *ptr) {
  preview2_string_free(&ptr->name);
}

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]descriptor")))
extern void __wasm_import_filesystem_descriptor_drop(int32_t handle);

void filesystem_descriptor_drop_own(filesystem_own_descriptor_t handle) {
  __wasm_import_filesystem_descriptor_drop(handle.__handle);
}

void filesystem_descriptor_drop_borrow(filesystem_borrow_descriptor_t handle) {
  __wasm_import_filesystem_descriptor_drop(handle.__handle);
}

filesystem_borrow_descriptor_t filesystem_borrow_descriptor(filesystem_own_descriptor_t arg) {
  return (filesystem_borrow_descriptor_t) { arg.__handle };
}

__attribute__((__import_module__("wasi:filesystem/types@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]directory-entry-stream")))
extern void __wasm_import_filesystem_directory_entry_stream_drop(int32_t handle);

void filesystem_directory_entry_stream_drop_own(filesystem_own_directory_entry_stream_t handle) {
  __wasm_import_filesystem_directory_entry_stream_drop(handle.__handle);
}

void filesystem_directory_entry_stream_drop_borrow(filesystem_borrow_directory_entry_stream_t handle) {
  __wasm_import_filesystem_directory_entry_stream_drop(handle.__handle);
}

filesystem_borrow_directory_entry_stream_t filesystem_borrow_directory_entry_stream(filesystem_own_directory_entry_stream_t arg) {
  return (filesystem_borrow_directory_entry_stream_t) { arg.__handle };
}

void filesystem_result_own_input_stream_error_code_free(filesystem_result_own_input_stream_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_own_output_stream_error_code_free(filesystem_result_own_output_stream_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_void_error_code_free(filesystem_result_void_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_descriptor_flags_error_code_free(filesystem_result_descriptor_flags_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_descriptor_type_error_code_free(filesystem_result_descriptor_type_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_tuple2_list_u8_bool_error_code_free(filesystem_result_tuple2_list_u8_bool_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_filesize_error_code_free(filesystem_result_filesize_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_own_directory_entry_stream_error_code_free(filesystem_result_own_directory_entry_stream_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_descriptor_stat_error_code_free(filesystem_result_descriptor_stat_error_code_t *ptr) {
  if (!ptr->is_err) {
    filesystem_descriptor_stat_free(&ptr->val.ok);
  } else {
  }
}

void filesystem_result_own_descriptor_error_code_free(filesystem_result_own_descriptor_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_result_string_error_code_free(filesystem_result_string_error_code_t *ptr) {
  if (!ptr->is_err) {
    preview2_string_free(&ptr->val.ok);
  } else {
  }
}

void filesystem_result_metadata_hash_value_error_code_free(filesystem_result_metadata_hash_value_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void filesystem_option_directory_entry_free(filesystem_option_directory_entry_t *ptr) {
  if (ptr->is_some) {
    filesystem_directory_entry_free(&ptr->val);
  }
}

void filesystem_result_option_directory_entry_error_code_free(filesystem_result_option_directory_entry_error_code_t *ptr) {
  if (!ptr->is_err) {
    filesystem_option_directory_entry_free(&ptr->val.ok);
  } else {
  }
}

void filesystem_option_error_code_free(filesystem_option_error_code_t *ptr) {
  if (ptr->is_some) {
  }
}

void filesystem_preopens_tuple2_own_descriptor_string_free(filesystem_preopens_tuple2_own_descriptor_string_t *ptr) {
  preview2_string_free(&ptr->f1);
}

void filesystem_preopens_list_tuple2_own_descriptor_string_free(filesystem_preopens_list_tuple2_own_descriptor_string_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
    filesystem_preopens_tuple2_own_descriptor_string_free(&ptr->ptr[i]);
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

__attribute__((__import_module__("wasi:sockets/network@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]network")))
extern void __wasm_import_network_network_drop(int32_t handle);

void network_network_drop_own(network_own_network_t handle) {
  __wasm_import_network_network_drop(handle.__handle);
}

void network_network_drop_borrow(network_borrow_network_t handle) {
  __wasm_import_network_network_drop(handle.__handle);
}

network_borrow_network_t network_borrow_network(network_own_network_t arg) {
  return (network_borrow_network_t) { arg.__handle };
}

void network_ip_address_free(network_ip_address_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      break;
    }
    case 1: {
      break;
    }
  }
}

void network_ip_socket_address_free(network_ip_socket_address_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      break;
    }
    case 1: {
      break;
    }
  }
}

void udp_ip_socket_address_free(udp_ip_socket_address_t *ptr) {
  network_ip_socket_address_free(ptr);
}

void udp_incoming_datagram_free(udp_incoming_datagram_t *ptr) {
  udp_ip_socket_address_free(&ptr->remote_address);
}

void udp_option_ip_socket_address_free(udp_option_ip_socket_address_t *ptr) {
  if (ptr->is_some) {
    udp_ip_socket_address_free(&ptr->val);
  }
}

void udp_outgoing_datagram_free(udp_outgoing_datagram_t *ptr) {
  udp_option_ip_socket_address_free(&ptr->remote_address);
}

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]udp-socket")))
extern void __wasm_import_udp_udp_socket_drop(int32_t handle);

void udp_udp_socket_drop_own(udp_own_udp_socket_t handle) {
  __wasm_import_udp_udp_socket_drop(handle.__handle);
}

void udp_udp_socket_drop_borrow(udp_borrow_udp_socket_t handle) {
  __wasm_import_udp_udp_socket_drop(handle.__handle);
}

udp_borrow_udp_socket_t udp_borrow_udp_socket(udp_own_udp_socket_t arg) {
  return (udp_borrow_udp_socket_t) { arg.__handle };
}

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]incoming-datagram-stream")))
extern void __wasm_import_udp_incoming_datagram_stream_drop(int32_t handle);

void udp_incoming_datagram_stream_drop_own(udp_own_incoming_datagram_stream_t handle) {
  __wasm_import_udp_incoming_datagram_stream_drop(handle.__handle);
}

void udp_incoming_datagram_stream_drop_borrow(udp_borrow_incoming_datagram_stream_t handle) {
  __wasm_import_udp_incoming_datagram_stream_drop(handle.__handle);
}

udp_borrow_incoming_datagram_stream_t udp_borrow_incoming_datagram_stream(udp_own_incoming_datagram_stream_t arg) {
  return (udp_borrow_incoming_datagram_stream_t) { arg.__handle };
}

__attribute__((__import_module__("wasi:sockets/udp@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]outgoing-datagram-stream")))
extern void __wasm_import_udp_outgoing_datagram_stream_drop(int32_t handle);

void udp_outgoing_datagram_stream_drop_own(udp_own_outgoing_datagram_stream_t handle) {
  __wasm_import_udp_outgoing_datagram_stream_drop(handle.__handle);
}

void udp_outgoing_datagram_stream_drop_borrow(udp_borrow_outgoing_datagram_stream_t handle) {
  __wasm_import_udp_outgoing_datagram_stream_drop(handle.__handle);
}

udp_borrow_outgoing_datagram_stream_t udp_borrow_outgoing_datagram_stream(udp_own_outgoing_datagram_stream_t arg) {
  return (udp_borrow_outgoing_datagram_stream_t) { arg.__handle };
}

void udp_result_void_error_code_free(udp_result_void_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void udp_result_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_error_code_free(udp_result_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void udp_result_ip_socket_address_error_code_free(udp_result_ip_socket_address_error_code_t *ptr) {
  if (!ptr->is_err) {
    udp_ip_socket_address_free(&ptr->val.ok);
  } else {
  }
}

void udp_result_bool_error_code_free(udp_result_bool_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void udp_result_u8_error_code_free(udp_result_u8_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void udp_result_u64_error_code_free(udp_result_u64_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void udp_list_incoming_datagram_free(udp_list_incoming_datagram_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
    udp_incoming_datagram_free(&ptr->ptr[i]);
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void udp_result_list_incoming_datagram_error_code_free(udp_result_list_incoming_datagram_error_code_t *ptr) {
  if (!ptr->is_err) {
    udp_list_incoming_datagram_free(&ptr->val.ok);
  } else {
  }
}

void udp_list_outgoing_datagram_free(udp_list_outgoing_datagram_t *ptr) {
  for (size_t i = 0; i < ptr->len; i++) {
    udp_outgoing_datagram_free(&ptr->ptr[i]);
  }
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void udp_create_socket_result_own_udp_socket_error_code_free(udp_create_socket_result_own_udp_socket_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_ip_socket_address_free(tcp_ip_socket_address_t *ptr) {
  network_ip_socket_address_free(ptr);
}

__attribute__((__import_module__("wasi:sockets/tcp@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]tcp-socket")))
extern void __wasm_import_tcp_tcp_socket_drop(int32_t handle);

void tcp_tcp_socket_drop_own(tcp_own_tcp_socket_t handle) {
  __wasm_import_tcp_tcp_socket_drop(handle.__handle);
}

void tcp_tcp_socket_drop_borrow(tcp_borrow_tcp_socket_t handle) {
  __wasm_import_tcp_tcp_socket_drop(handle.__handle);
}

tcp_borrow_tcp_socket_t tcp_borrow_tcp_socket(tcp_own_tcp_socket_t arg) {
  return (tcp_borrow_tcp_socket_t) { arg.__handle };
}

void tcp_result_void_error_code_free(tcp_result_void_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_result_tuple2_own_input_stream_own_output_stream_error_code_free(tcp_result_tuple2_own_input_stream_own_output_stream_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_free(tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_result_ip_socket_address_error_code_free(tcp_result_ip_socket_address_error_code_t *ptr) {
  if (!ptr->is_err) {
    tcp_ip_socket_address_free(&ptr->val.ok);
  } else {
  }
}

void tcp_result_bool_error_code_free(tcp_result_bool_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_result_duration_error_code_free(tcp_result_duration_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_result_u32_error_code_free(tcp_result_u32_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_result_u8_error_code_free(tcp_result_u8_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_result_u64_error_code_free(tcp_result_u64_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void tcp_create_socket_result_own_tcp_socket_error_code_free(tcp_create_socket_result_own_tcp_socket_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void ip_name_lookup_ip_address_free(ip_name_lookup_ip_address_t *ptr) {
  network_ip_address_free(ptr);
}

__attribute__((__import_module__("wasi:sockets/ip-name-lookup@0.2.0-rc-2023-11-10"), __import_name__("[resource-drop]resolve-address-stream")))
extern void __wasm_import_ip_name_lookup_resolve_address_stream_drop(int32_t handle);

void ip_name_lookup_resolve_address_stream_drop_own(ip_name_lookup_own_resolve_address_stream_t handle) {
  __wasm_import_ip_name_lookup_resolve_address_stream_drop(handle.__handle);
}

void ip_name_lookup_resolve_address_stream_drop_borrow(ip_name_lookup_borrow_resolve_address_stream_t handle) {
  __wasm_import_ip_name_lookup_resolve_address_stream_drop(handle.__handle);
}

ip_name_lookup_borrow_resolve_address_stream_t ip_name_lookup_borrow_resolve_address_stream(ip_name_lookup_own_resolve_address_stream_t arg) {
  return (ip_name_lookup_borrow_resolve_address_stream_t) { arg.__handle };
}

void ip_name_lookup_result_own_resolve_address_stream_error_code_free(ip_name_lookup_result_own_resolve_address_stream_error_code_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void ip_name_lookup_option_ip_address_free(ip_name_lookup_option_ip_address_t *ptr) {
  if (ptr->is_some) {
    ip_name_lookup_ip_address_free(&ptr->val);
  }
}

void ip_name_lookup_result_option_ip_address_error_code_free(ip_name_lookup_result_option_ip_address_error_code_t *ptr) {
  if (!ptr->is_err) {
    ip_name_lookup_option_ip_address_free(&ptr->val.ok);
  } else {
  }
}

void preview2_string_set(preview2_string_t *ret, char*s) {
  ret->ptr = (uint8_t*) s;
  ret->len = strlen(s);
}

void preview2_string_dup(preview2_string_t *ret, const char*s) {
  ret->len = strlen(s);
  ret->ptr = cabi_realloc(NULL, 0, 1, ret->len * 1);
  memcpy(ret->ptr, s, ret->len * 1);
}

void preview2_string_free(preview2_string_t *ret) {
  if (ret->len > 0) {
    free(ret->ptr);
  }
  ret->ptr = NULL;
  ret->len = 0;
}

// Component Adapters

void environment_get_environment(preview2_list_tuple2_string_string_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_environment_get_environment(ptr);
  *ret = (preview2_list_tuple2_string_string_t) { (preview2_tuple2_string_string_t*)(*((int32_t*) (ptr + 0))), (size_t)(*((int32_t*) (ptr + 4))) };
}

void environment_get_arguments(preview2_list_string_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_environment_get_arguments(ptr);
  *ret = (preview2_list_string_t) { (preview2_string_t*)(*((int32_t*) (ptr + 0))), (size_t)(*((int32_t*) (ptr + 4))) };
}

bool environment_initial_cwd(preview2_string_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_environment_initial_cwd(ptr);
  preview2_option_string_t option;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (preview2_string_t) { (uint8_t*)(*((int32_t*) (ptr + 4))), (size_t)(*((int32_t*) (ptr + 8))) };
      break;
    }
  }
  *ret = option.val;
  return option.is_some;
}

void exit_exit(exit_result_void_void_t *status) {
  int32_t result;
  if ((*status).is_err) {
    result = 1;
  } else {
    result = 0;
  }
  __wasm_import_exit_exit(result);
}

void io_error_method_error_to_debug_string(io_error_borrow_error_t self, preview2_string_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_io_error_method_error_to_debug_string((self).__handle, ptr);
  *ret = (preview2_string_t) { (uint8_t*)(*((int32_t*) (ptr + 0))), (size_t)(*((int32_t*) (ptr + 4))) };
}

bool poll_method_pollable_ready(poll_borrow_pollable_t self) {
  int32_t ret = __wasm_import_poll_method_pollable_ready((self).__handle);
  return ret;
}

void poll_method_pollable_block(poll_borrow_pollable_t self) {
  __wasm_import_poll_method_pollable_block((self).__handle);
}

void poll_poll(poll_list_borrow_pollable_t *in, preview2_list_u32_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_poll_poll((int32_t) (*in).ptr, (int32_t) (*in).len, ptr);
  *ret = (preview2_list_u32_t) { (uint32_t*)(*((int32_t*) (ptr + 0))), (size_t)(*((int32_t*) (ptr + 4))) };
}

bool streams_method_input_stream_read(streams_borrow_input_stream_t self, uint64_t len, preview2_list_u8_t *ret, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_input_stream_read((self).__handle, (int64_t) (len), ptr);
  streams_result_list_u8_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (preview2_list_u8_t) { (uint8_t*)(*((int32_t*) (ptr + 4))), (size_t)(*((int32_t*) (ptr + 8))) };
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_input_stream_blocking_read(streams_borrow_input_stream_t self, uint64_t len, preview2_list_u8_t *ret, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_input_stream_blocking_read((self).__handle, (int64_t) (len), ptr);
  streams_result_list_u8_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (preview2_list_u8_t) { (uint8_t*)(*((int32_t*) (ptr + 4))), (size_t)(*((int32_t*) (ptr + 8))) };
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_input_stream_skip(streams_borrow_input_stream_t self, uint64_t len, uint64_t *ret, streams_stream_error_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_input_stream_skip((self).__handle, (int64_t) (len), ptr);
  streams_result_u64_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 8)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 12)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_input_stream_blocking_skip(streams_borrow_input_stream_t self, uint64_t len, uint64_t *ret, streams_stream_error_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_input_stream_blocking_skip((self).__handle, (int64_t) (len), ptr);
  streams_result_u64_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 8)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 12)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

streams_own_pollable_t streams_method_input_stream_subscribe(streams_borrow_input_stream_t self) {
  int32_t ret = __wasm_import_streams_method_input_stream_subscribe((self).__handle);
  return (streams_own_pollable_t) { ret };
}

bool streams_method_output_stream_check_write(streams_borrow_output_stream_t self, uint64_t *ret, streams_stream_error_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_check_write((self).__handle, ptr);
  streams_result_u64_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 8)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 12)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_output_stream_write(streams_borrow_output_stream_t self, preview2_list_u8_t *contents, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_write((self).__handle, (int32_t) (*contents).ptr, (int32_t) (*contents).len, ptr);
  streams_result_void_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_output_stream_blocking_write_and_flush(streams_borrow_output_stream_t self, preview2_list_u8_t *contents, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_blocking_write_and_flush((self).__handle, (int32_t) (*contents).ptr, (int32_t) (*contents).len, ptr);
  streams_result_void_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_output_stream_flush(streams_borrow_output_stream_t self, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_flush((self).__handle, ptr);
  streams_result_void_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_output_stream_blocking_flush(streams_borrow_output_stream_t self, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_blocking_flush((self).__handle, ptr);
  streams_result_void_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

streams_own_pollable_t streams_method_output_stream_subscribe(streams_borrow_output_stream_t self) {
  int32_t ret = __wasm_import_streams_method_output_stream_subscribe((self).__handle);
  return (streams_own_pollable_t) { ret };
}

bool streams_method_output_stream_write_zeroes(streams_borrow_output_stream_t self, uint64_t len, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_write_zeroes((self).__handle, (int64_t) (len), ptr);
  streams_result_void_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_output_stream_blocking_write_zeroes_and_flush(streams_borrow_output_stream_t self, uint64_t len, streams_stream_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_blocking_write_zeroes_and_flush((self).__handle, (int64_t) (len), ptr);
  streams_result_void_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 8)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_output_stream_splice(streams_borrow_output_stream_t self, streams_borrow_input_stream_t src, uint64_t len, uint64_t *ret, streams_stream_error_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_splice((self).__handle, (src).__handle, (int64_t) (len), ptr);
  streams_result_u64_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 8)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 12)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool streams_method_output_stream_blocking_splice(streams_borrow_output_stream_t self, streams_borrow_input_stream_t src, uint64_t len, uint64_t *ret, streams_stream_error_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_streams_method_output_stream_blocking_splice((self).__handle, (src).__handle, (int64_t) (len), ptr);
  streams_result_u64_stream_error_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      streams_stream_error_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 8)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.last_operation_failed = (streams_own_error_t) { *((int32_t*) (ptr + 12)) };
          break;
        }
        case 1: {
          break;
        }
      }
      
      result.val.err = variant;
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

stdin_own_input_stream_t stdin_get_stdin(void) {
  int32_t ret = __wasm_import_stdin_get_stdin();
  return (stdin_own_input_stream_t) { ret };
}

stdout_own_output_stream_t stdout_get_stdout(void) {
  int32_t ret = __wasm_import_stdout_get_stdout();
  return (stdout_own_output_stream_t) { ret };
}

stderr_own_output_stream_t stderr_get_stderr(void) {
  int32_t ret = __wasm_import_stderr_get_stderr();
  return (stderr_own_output_stream_t) { ret };
}

bool terminal_stdin_get_terminal_stdin(terminal_stdin_own_terminal_input_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_terminal_stdin_get_terminal_stdin(ptr);
  terminal_stdin_option_own_terminal_input_t option;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (terminal_stdin_own_terminal_input_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
  }
  *ret = option.val;
  return option.is_some;
}

bool terminal_stdout_get_terminal_stdout(terminal_stdout_own_terminal_output_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_terminal_stdout_get_terminal_stdout(ptr);
  terminal_stdout_option_own_terminal_output_t option;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (terminal_stdout_own_terminal_output_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
  }
  *ret = option.val;
  return option.is_some;
}

bool terminal_stderr_get_terminal_stderr(terminal_stderr_own_terminal_output_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_terminal_stderr_get_terminal_stderr(ptr);
  terminal_stderr_option_own_terminal_output_t option;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (terminal_stderr_own_terminal_output_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
  }
  *ret = option.val;
  return option.is_some;
}

monotonic_clock_instant_t monotonic_clock_now(void) {
  int64_t ret = __wasm_import_monotonic_clock_now();
  return (uint64_t) (ret);
}

monotonic_clock_duration_t monotonic_clock_resolution(void) {
  int64_t ret = __wasm_import_monotonic_clock_resolution();
  return (uint64_t) (ret);
}

monotonic_clock_own_pollable_t monotonic_clock_subscribe_instant(monotonic_clock_instant_t when) {
  int32_t ret = __wasm_import_monotonic_clock_subscribe_instant((int64_t) (when));
  return (monotonic_clock_own_pollable_t) { ret };
}

monotonic_clock_own_pollable_t monotonic_clock_subscribe_duration(monotonic_clock_duration_t when) {
  int32_t ret = __wasm_import_monotonic_clock_subscribe_duration((int64_t) (when));
  return (monotonic_clock_own_pollable_t) { ret };
}

void wall_clock_now(wall_clock_datetime_t *ret) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_wall_clock_now(ptr);
  *ret = (wall_clock_datetime_t) {
    (uint64_t) (*((int64_t*) (ptr + 0))),
    (uint32_t) (*((int32_t*) (ptr + 8))),
  };
}

void wall_clock_resolution(wall_clock_datetime_t *ret) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_wall_clock_resolution(ptr);
  *ret = (wall_clock_datetime_t) {
    (uint64_t) (*((int64_t*) (ptr + 0))),
    (uint32_t) (*((int32_t*) (ptr + 8))),
  };
}

bool filesystem_method_descriptor_read_via_stream(filesystem_borrow_descriptor_t self, filesystem_filesize_t offset, filesystem_own_input_stream_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_read_via_stream((self).__handle, (int64_t) (offset), ptr);
  filesystem_result_own_input_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (filesystem_own_input_stream_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_write_via_stream(filesystem_borrow_descriptor_t self, filesystem_filesize_t offset, filesystem_own_output_stream_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_write_via_stream((self).__handle, (int64_t) (offset), ptr);
  filesystem_result_own_output_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (filesystem_own_output_stream_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_append_via_stream(filesystem_borrow_descriptor_t self, filesystem_own_output_stream_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_append_via_stream((self).__handle, ptr);
  filesystem_result_own_output_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (filesystem_own_output_stream_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_advise(filesystem_borrow_descriptor_t self, filesystem_filesize_t offset, filesystem_filesize_t length, filesystem_advice_t advice, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_advise((self).__handle, (int64_t) (offset), (int64_t) (length), (int32_t) advice, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_sync_data(filesystem_borrow_descriptor_t self, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_sync_data((self).__handle, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_get_flags(filesystem_borrow_descriptor_t self, filesystem_descriptor_flags_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_get_flags((self).__handle, ptr);
  filesystem_result_descriptor_flags_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_get_type(filesystem_borrow_descriptor_t self, filesystem_descriptor_type_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_get_type((self).__handle, ptr);
  filesystem_result_descriptor_type_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_set_size(filesystem_borrow_descriptor_t self, filesystem_filesize_t size, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_set_size((self).__handle, (int64_t) (size), ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_set_times(filesystem_borrow_descriptor_t self, filesystem_new_timestamp_t *data_access_timestamp, filesystem_new_timestamp_t *data_modification_timestamp, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t variant;
  int64_t variant2;
  int32_t variant3;
  switch ((int32_t) (*data_access_timestamp).tag) {
    case 0: {
      variant = 0;
      variant2 = 0;
      variant3 = 0;
      break;
    }
    case 1: {
      variant = 1;
      variant2 = 0;
      variant3 = 0;
      break;
    }
    case 2: {
      const filesystem_datetime_t *payload1 = &(*data_access_timestamp).val.timestamp;
      variant = 2;
      variant2 = (int64_t) ((*payload1).seconds);
      variant3 = (int32_t) ((*payload1).nanoseconds);
      break;
    }
  }
  int32_t variant7;
  int64_t variant8;
  int32_t variant9;
  switch ((int32_t) (*data_modification_timestamp).tag) {
    case 0: {
      variant7 = 0;
      variant8 = 0;
      variant9 = 0;
      break;
    }
    case 1: {
      variant7 = 1;
      variant8 = 0;
      variant9 = 0;
      break;
    }
    case 2: {
      const filesystem_datetime_t *payload6 = &(*data_modification_timestamp).val.timestamp;
      variant7 = 2;
      variant8 = (int64_t) ((*payload6).seconds);
      variant9 = (int32_t) ((*payload6).nanoseconds);
      break;
    }
  }
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_set_times((self).__handle, variant, variant2, variant3, variant7, variant8, variant9, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_read(filesystem_borrow_descriptor_t self, filesystem_filesize_t length, filesystem_filesize_t offset, preview2_tuple2_list_u8_bool_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_read((self).__handle, (int64_t) (length), (int64_t) (offset), ptr);
  filesystem_result_tuple2_list_u8_bool_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (preview2_tuple2_list_u8_bool_t) {
        (preview2_list_u8_t) { (uint8_t*)(*((int32_t*) (ptr + 4))), (size_t)(*((int32_t*) (ptr + 8))) },
        (int32_t) (*((uint8_t*) (ptr + 12))),
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_write(filesystem_borrow_descriptor_t self, preview2_list_u8_t *buffer, filesystem_filesize_t offset, filesystem_filesize_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_write((self).__handle, (int32_t) (*buffer).ptr, (int32_t) (*buffer).len, (int64_t) (offset), ptr);
  filesystem_result_filesize_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_read_directory(filesystem_borrow_descriptor_t self, filesystem_own_directory_entry_stream_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_read_directory((self).__handle, ptr);
  filesystem_result_own_directory_entry_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (filesystem_own_directory_entry_stream_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_sync(filesystem_borrow_descriptor_t self, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_sync((self).__handle, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_create_directory_at(filesystem_borrow_descriptor_t self, preview2_string_t *path, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_create_directory_at((self).__handle, (int32_t) (*path).ptr, (int32_t) (*path).len, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_stat(filesystem_borrow_descriptor_t self, filesystem_descriptor_stat_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[104];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_stat((self).__handle, ptr);
  filesystem_result_descriptor_stat_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      filesystem_option_datetime_t option;
      switch ((int32_t) (*((uint8_t*) (ptr + 32)))) {
        case 0: {
          option.is_some = false;
          break;
        }
        case 1: {
          option.is_some = true;
          option.val = (wall_clock_datetime_t) {
            (uint64_t) (*((int64_t*) (ptr + 40))),
            (uint32_t) (*((int32_t*) (ptr + 48))),
          };
          break;
        }
      }
      filesystem_option_datetime_t option0;
      switch ((int32_t) (*((uint8_t*) (ptr + 56)))) {
        case 0: {
          option0.is_some = false;
          break;
        }
        case 1: {
          option0.is_some = true;
          option0.val = (wall_clock_datetime_t) {
            (uint64_t) (*((int64_t*) (ptr + 64))),
            (uint32_t) (*((int32_t*) (ptr + 72))),
          };
          break;
        }
      }
      filesystem_option_datetime_t option1;
      switch ((int32_t) (*((uint8_t*) (ptr + 80)))) {
        case 0: {
          option1.is_some = false;
          break;
        }
        case 1: {
          option1.is_some = true;
          option1.val = (wall_clock_datetime_t) {
            (uint64_t) (*((int64_t*) (ptr + 88))),
            (uint32_t) (*((int32_t*) (ptr + 96))),
          };
          break;
        }
      }
      
      result.val.ok = (filesystem_descriptor_stat_t) {
        (int32_t) (*((uint8_t*) (ptr + 8))),
        (uint64_t) (*((int64_t*) (ptr + 16))),
        (uint64_t) (*((int64_t*) (ptr + 24))),
        option,
        option0,
        option1,
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_stat_at(filesystem_borrow_descriptor_t self, filesystem_path_flags_t path_flags, preview2_string_t *path, filesystem_descriptor_stat_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[104];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_stat_at((self).__handle, path_flags, (int32_t) (*path).ptr, (int32_t) (*path).len, ptr);
  filesystem_result_descriptor_stat_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      filesystem_option_datetime_t option;
      switch ((int32_t) (*((uint8_t*) (ptr + 32)))) {
        case 0: {
          option.is_some = false;
          break;
        }
        case 1: {
          option.is_some = true;
          option.val = (wall_clock_datetime_t) {
            (uint64_t) (*((int64_t*) (ptr + 40))),
            (uint32_t) (*((int32_t*) (ptr + 48))),
          };
          break;
        }
      }
      filesystem_option_datetime_t option0;
      switch ((int32_t) (*((uint8_t*) (ptr + 56)))) {
        case 0: {
          option0.is_some = false;
          break;
        }
        case 1: {
          option0.is_some = true;
          option0.val = (wall_clock_datetime_t) {
            (uint64_t) (*((int64_t*) (ptr + 64))),
            (uint32_t) (*((int32_t*) (ptr + 72))),
          };
          break;
        }
      }
      filesystem_option_datetime_t option1;
      switch ((int32_t) (*((uint8_t*) (ptr + 80)))) {
        case 0: {
          option1.is_some = false;
          break;
        }
        case 1: {
          option1.is_some = true;
          option1.val = (wall_clock_datetime_t) {
            (uint64_t) (*((int64_t*) (ptr + 88))),
            (uint32_t) (*((int32_t*) (ptr + 96))),
          };
          break;
        }
      }
      
      result.val.ok = (filesystem_descriptor_stat_t) {
        (int32_t) (*((uint8_t*) (ptr + 8))),
        (uint64_t) (*((int64_t*) (ptr + 16))),
        (uint64_t) (*((int64_t*) (ptr + 24))),
        option,
        option0,
        option1,
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_set_times_at(filesystem_borrow_descriptor_t self, filesystem_path_flags_t path_flags, preview2_string_t *path, filesystem_new_timestamp_t *data_access_timestamp, filesystem_new_timestamp_t *data_modification_timestamp, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t variant;
  int64_t variant2;
  int32_t variant3;
  switch ((int32_t) (*data_access_timestamp).tag) {
    case 0: {
      variant = 0;
      variant2 = 0;
      variant3 = 0;
      break;
    }
    case 1: {
      variant = 1;
      variant2 = 0;
      variant3 = 0;
      break;
    }
    case 2: {
      const filesystem_datetime_t *payload1 = &(*data_access_timestamp).val.timestamp;
      variant = 2;
      variant2 = (int64_t) ((*payload1).seconds);
      variant3 = (int32_t) ((*payload1).nanoseconds);
      break;
    }
  }
  int32_t variant7;
  int64_t variant8;
  int32_t variant9;
  switch ((int32_t) (*data_modification_timestamp).tag) {
    case 0: {
      variant7 = 0;
      variant8 = 0;
      variant9 = 0;
      break;
    }
    case 1: {
      variant7 = 1;
      variant8 = 0;
      variant9 = 0;
      break;
    }
    case 2: {
      const filesystem_datetime_t *payload6 = &(*data_modification_timestamp).val.timestamp;
      variant7 = 2;
      variant8 = (int64_t) ((*payload6).seconds);
      variant9 = (int32_t) ((*payload6).nanoseconds);
      break;
    }
  }
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_set_times_at((self).__handle, path_flags, (int32_t) (*path).ptr, (int32_t) (*path).len, variant, variant2, variant3, variant7, variant8, variant9, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_link_at(filesystem_borrow_descriptor_t self, filesystem_path_flags_t old_path_flags, preview2_string_t *old_path, filesystem_borrow_descriptor_t new_descriptor, preview2_string_t *new_path, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_link_at((self).__handle, old_path_flags, (int32_t) (*old_path).ptr, (int32_t) (*old_path).len, (new_descriptor).__handle, (int32_t) (*new_path).ptr, (int32_t) (*new_path).len, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_open_at(filesystem_borrow_descriptor_t self, filesystem_path_flags_t path_flags, preview2_string_t *path, filesystem_open_flags_t open_flags, filesystem_descriptor_flags_t flags, filesystem_own_descriptor_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_open_at((self).__handle, path_flags, (int32_t) (*path).ptr, (int32_t) (*path).len, open_flags, flags, ptr);
  filesystem_result_own_descriptor_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (filesystem_own_descriptor_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_readlink_at(filesystem_borrow_descriptor_t self, preview2_string_t *path, preview2_string_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_readlink_at((self).__handle, (int32_t) (*path).ptr, (int32_t) (*path).len, ptr);
  filesystem_result_string_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (preview2_string_t) { (uint8_t*)(*((int32_t*) (ptr + 4))), (size_t)(*((int32_t*) (ptr + 8))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_remove_directory_at(filesystem_borrow_descriptor_t self, preview2_string_t *path, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_remove_directory_at((self).__handle, (int32_t) (*path).ptr, (int32_t) (*path).len, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_rename_at(filesystem_borrow_descriptor_t self, preview2_string_t *old_path, filesystem_borrow_descriptor_t new_descriptor, preview2_string_t *new_path, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_rename_at((self).__handle, (int32_t) (*old_path).ptr, (int32_t) (*old_path).len, (new_descriptor).__handle, (int32_t) (*new_path).ptr, (int32_t) (*new_path).len, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_symlink_at(filesystem_borrow_descriptor_t self, preview2_string_t *old_path, preview2_string_t *new_path, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_symlink_at((self).__handle, (int32_t) (*old_path).ptr, (int32_t) (*old_path).len, (int32_t) (*new_path).ptr, (int32_t) (*new_path).len, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_unlink_file_at(filesystem_borrow_descriptor_t self, preview2_string_t *path, filesystem_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_unlink_file_at((self).__handle, (int32_t) (*path).ptr, (int32_t) (*path).len, ptr);
  filesystem_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_is_same_object(filesystem_borrow_descriptor_t self, filesystem_borrow_descriptor_t other) {
  int32_t ret = __wasm_import_filesystem_method_descriptor_is_same_object((self).__handle, (other).__handle);
  return ret;
}

bool filesystem_method_descriptor_metadata_hash(filesystem_borrow_descriptor_t self, filesystem_metadata_hash_value_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[24];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_metadata_hash((self).__handle, ptr);
  filesystem_result_metadata_hash_value_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (filesystem_metadata_hash_value_t) {
        (uint64_t) (*((int64_t*) (ptr + 8))),
        (uint64_t) (*((int64_t*) (ptr + 16))),
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_descriptor_metadata_hash_at(filesystem_borrow_descriptor_t self, filesystem_path_flags_t path_flags, preview2_string_t *path, filesystem_metadata_hash_value_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[24];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_descriptor_metadata_hash_at((self).__handle, path_flags, (int32_t) (*path).ptr, (int32_t) (*path).len, ptr);
  filesystem_result_metadata_hash_value_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (filesystem_metadata_hash_value_t) {
        (uint64_t) (*((int64_t*) (ptr + 8))),
        (uint64_t) (*((int64_t*) (ptr + 16))),
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_method_directory_entry_stream_read_directory_entry(filesystem_borrow_directory_entry_stream_t self, filesystem_option_directory_entry_t *ret, filesystem_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[20];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_method_directory_entry_stream_read_directory_entry((self).__handle, ptr);
  filesystem_result_option_directory_entry_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      filesystem_option_directory_entry_t option;
      switch ((int32_t) (*((uint8_t*) (ptr + 4)))) {
        case 0: {
          option.is_some = false;
          break;
        }
        case 1: {
          option.is_some = true;
          option.val = (filesystem_directory_entry_t) {
            (int32_t) (*((uint8_t*) (ptr + 8))),
            (preview2_string_t) { (uint8_t*)(*((int32_t*) (ptr + 12))), (size_t)(*((int32_t*) (ptr + 16))) },
          };
          break;
        }
      }
      
      result.val.ok = option;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool filesystem_filesystem_error_code(filesystem_borrow_error_t err_, filesystem_error_code_t *ret) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_filesystem_error_code((err_).__handle, ptr);
  filesystem_option_error_code_t option;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  *ret = option.val;
  return option.is_some;
}

void filesystem_preopens_get_directories(filesystem_preopens_list_tuple2_own_descriptor_string_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_filesystem_preopens_get_directories(ptr);
  *ret = (filesystem_preopens_list_tuple2_own_descriptor_string_t) { (filesystem_preopens_tuple2_own_descriptor_string_t*)(*((int32_t*) (ptr + 0))), (size_t)(*((int32_t*) (ptr + 4))) };
}

instance_network_own_network_t instance_network_instance_network(void) {
  int32_t ret = __wasm_import_instance_network_instance_network();
  return (instance_network_own_network_t) { ret };
}

bool udp_method_udp_socket_start_bind(udp_borrow_udp_socket_t self, udp_borrow_network_t network, udp_ip_socket_address_t *local_address, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t variant;
  int32_t variant1;
  int32_t variant2;
  int32_t variant3;
  int32_t variant4;
  int32_t variant5;
  int32_t variant6;
  int32_t variant7;
  int32_t variant8;
  int32_t variant9;
  int32_t variant10;
  int32_t variant11;
  switch ((int32_t) (*local_address).tag) {
    case 0: {
      const network_ipv4_socket_address_t *payload = &(*local_address).val.ipv4;
      variant = 0;
      variant1 = (int32_t) ((*payload).port);
      variant2 = (int32_t) (((*payload).address).f0);
      variant3 = (int32_t) (((*payload).address).f1);
      variant4 = (int32_t) (((*payload).address).f2);
      variant5 = (int32_t) (((*payload).address).f3);
      variant6 = 0;
      variant7 = 0;
      variant8 = 0;
      variant9 = 0;
      variant10 = 0;
      variant11 = 0;
      break;
    }
    case 1: {
      const network_ipv6_socket_address_t *payload0 = &(*local_address).val.ipv6;
      variant = 1;
      variant1 = (int32_t) ((*payload0).port);
      variant2 = (int32_t) ((*payload0).flow_info);
      variant3 = (int32_t) (((*payload0).address).f0);
      variant4 = (int32_t) (((*payload0).address).f1);
      variant5 = (int32_t) (((*payload0).address).f2);
      variant6 = (int32_t) (((*payload0).address).f3);
      variant7 = (int32_t) (((*payload0).address).f4);
      variant8 = (int32_t) (((*payload0).address).f5);
      variant9 = (int32_t) (((*payload0).address).f6);
      variant10 = (int32_t) (((*payload0).address).f7);
      variant11 = (int32_t) ((*payload0).scope_id);
      break;
    }
  }
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_start_bind((self).__handle, (network).__handle, variant, variant1, variant2, variant3, variant4, variant5, variant6, variant7, variant8, variant9, variant10, variant11, ptr);
  udp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_finish_bind(udp_borrow_udp_socket_t self, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_finish_bind((self).__handle, ptr);
  udp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_stream(udp_borrow_udp_socket_t self, udp_ip_socket_address_t *maybe_remote_address, udp_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  udp_option_ip_socket_address_t remote_address;
  remote_address.is_some = maybe_remote_address != NULL;if (maybe_remote_address) {
    remote_address.val = *maybe_remote_address;
  }
  int32_t option;
  int32_t option14;
  int32_t option15;
  int32_t option16;
  int32_t option17;
  int32_t option18;
  int32_t option19;
  int32_t option20;
  int32_t option21;
  int32_t option22;
  int32_t option23;
  int32_t option24;
  int32_t option25;
  if ((remote_address).is_some) {
    const udp_ip_socket_address_t *payload0 = &(remote_address).val;
    int32_t variant;
    int32_t variant3;
    int32_t variant4;
    int32_t variant5;
    int32_t variant6;
    int32_t variant7;
    int32_t variant8;
    int32_t variant9;
    int32_t variant10;
    int32_t variant11;
    int32_t variant12;
    int32_t variant13;
    switch ((int32_t) (*payload0).tag) {
      case 0: {
        const network_ipv4_socket_address_t *payload1 = &(*payload0).val.ipv4;
        variant = 0;
        variant3 = (int32_t) ((*payload1).port);
        variant4 = (int32_t) (((*payload1).address).f0);
        variant5 = (int32_t) (((*payload1).address).f1);
        variant6 = (int32_t) (((*payload1).address).f2);
        variant7 = (int32_t) (((*payload1).address).f3);
        variant8 = 0;
        variant9 = 0;
        variant10 = 0;
        variant11 = 0;
        variant12 = 0;
        variant13 = 0;
        break;
      }
      case 1: {
        const network_ipv6_socket_address_t *payload2 = &(*payload0).val.ipv6;
        variant = 1;
        variant3 = (int32_t) ((*payload2).port);
        variant4 = (int32_t) ((*payload2).flow_info);
        variant5 = (int32_t) (((*payload2).address).f0);
        variant6 = (int32_t) (((*payload2).address).f1);
        variant7 = (int32_t) (((*payload2).address).f2);
        variant8 = (int32_t) (((*payload2).address).f3);
        variant9 = (int32_t) (((*payload2).address).f4);
        variant10 = (int32_t) (((*payload2).address).f5);
        variant11 = (int32_t) (((*payload2).address).f6);
        variant12 = (int32_t) (((*payload2).address).f7);
        variant13 = (int32_t) ((*payload2).scope_id);
        break;
      }
    }
    option = 1;
    option14 = variant;
    option15 = variant3;
    option16 = variant4;
    option17 = variant5;
    option18 = variant6;
    option19 = variant7;
    option20 = variant8;
    option21 = variant9;
    option22 = variant10;
    option23 = variant11;
    option24 = variant12;
    option25 = variant13;
  } else {
    option = 0;
    option14 = 0;
    option15 = 0;
    option16 = 0;
    option17 = 0;
    option18 = 0;
    option19 = 0;
    option20 = 0;
    option21 = 0;
    option22 = 0;
    option23 = 0;
    option24 = 0;
    option25 = 0;
  }
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_stream((self).__handle, option, option14, option15, option16, option17, option18, option19, option20, option21, option22, option23, option24, option25, ptr);
  udp_result_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (udp_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_t) {
        (udp_own_incoming_datagram_stream_t) { *((int32_t*) (ptr + 4)) },
        (udp_own_outgoing_datagram_stream_t) { *((int32_t*) (ptr + 8)) },
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_local_address(udp_borrow_udp_socket_t self, udp_ip_socket_address_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[36];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_local_address((self).__handle, ptr);
  udp_result_ip_socket_address_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      network_ip_socket_address_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.ipv4 = (network_ipv4_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (network_ipv4_address_t) {
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 10)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 11)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 12)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 13)))),
            },
          };
          break;
        }
        case 1: {
          variant.val.ipv6 = (network_ipv6_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (uint32_t) (*((int32_t*) (ptr + 12))),
            (network_ipv6_address_t) {
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 16)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 18)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 20)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 22)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 24)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 26)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 28)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 30)))),
            },
            (uint32_t) (*((int32_t*) (ptr + 32))),
          };
          break;
        }
      }
      
      result.val.ok = variant;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_remote_address(udp_borrow_udp_socket_t self, udp_ip_socket_address_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[36];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_remote_address((self).__handle, ptr);
  udp_result_ip_socket_address_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      network_ip_socket_address_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.ipv4 = (network_ipv4_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (network_ipv4_address_t) {
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 10)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 11)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 12)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 13)))),
            },
          };
          break;
        }
        case 1: {
          variant.val.ipv6 = (network_ipv6_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (uint32_t) (*((int32_t*) (ptr + 12))),
            (network_ipv6_address_t) {
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 16)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 18)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 20)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 22)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 24)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 26)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 28)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 30)))),
            },
            (uint32_t) (*((int32_t*) (ptr + 32))),
          };
          break;
        }
      }
      
      result.val.ok = variant;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

udp_ip_address_family_t udp_method_udp_socket_address_family(udp_borrow_udp_socket_t self) {
  int32_t ret = __wasm_import_udp_method_udp_socket_address_family((self).__handle);
  return ret;
}

bool udp_method_udp_socket_ipv6_only(udp_borrow_udp_socket_t self, bool *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_ipv6_only((self).__handle, ptr);
  udp_result_bool_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_set_ipv6_only(udp_borrow_udp_socket_t self, bool value, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_set_ipv6_only((self).__handle, value, ptr);
  udp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_unicast_hop_limit(udp_borrow_udp_socket_t self, uint8_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_unicast_hop_limit((self).__handle, ptr);
  udp_result_u8_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 1))));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_set_unicast_hop_limit(udp_borrow_udp_socket_t self, uint8_t value, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_set_unicast_hop_limit((self).__handle, (int32_t) (value), ptr);
  udp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_receive_buffer_size(udp_borrow_udp_socket_t self, uint64_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_receive_buffer_size((self).__handle, ptr);
  udp_result_u64_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_set_receive_buffer_size(udp_borrow_udp_socket_t self, uint64_t value, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_set_receive_buffer_size((self).__handle, (int64_t) (value), ptr);
  udp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_send_buffer_size(udp_borrow_udp_socket_t self, uint64_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_send_buffer_size((self).__handle, ptr);
  udp_result_u64_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_udp_socket_set_send_buffer_size(udp_borrow_udp_socket_t self, uint64_t value, udp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_udp_socket_set_send_buffer_size((self).__handle, (int64_t) (value), ptr);
  udp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

udp_own_pollable_t udp_method_udp_socket_subscribe(udp_borrow_udp_socket_t self) {
  int32_t ret = __wasm_import_udp_method_udp_socket_subscribe((self).__handle);
  return (udp_own_pollable_t) { ret };
}

bool udp_method_incoming_datagram_stream_receive(udp_borrow_incoming_datagram_stream_t self, uint64_t max_results, udp_list_incoming_datagram_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_incoming_datagram_stream_receive((self).__handle, (int64_t) (max_results), ptr);
  udp_result_list_incoming_datagram_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (udp_list_incoming_datagram_t) { (udp_incoming_datagram_t*)(*((int32_t*) (ptr + 4))), (size_t)(*((int32_t*) (ptr + 8))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

udp_own_pollable_t udp_method_incoming_datagram_stream_subscribe(udp_borrow_incoming_datagram_stream_t self) {
  int32_t ret = __wasm_import_udp_method_incoming_datagram_stream_subscribe((self).__handle);
  return (udp_own_pollable_t) { ret };
}

bool udp_method_outgoing_datagram_stream_check_send(udp_borrow_outgoing_datagram_stream_t self, uint64_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_outgoing_datagram_stream_check_send((self).__handle, ptr);
  udp_result_u64_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool udp_method_outgoing_datagram_stream_send(udp_borrow_outgoing_datagram_stream_t self, udp_list_outgoing_datagram_t *datagrams, uint64_t *ret, udp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_method_outgoing_datagram_stream_send((self).__handle, (int32_t) (*datagrams).ptr, (int32_t) (*datagrams).len, ptr);
  udp_result_u64_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

udp_own_pollable_t udp_method_outgoing_datagram_stream_subscribe(udp_borrow_outgoing_datagram_stream_t self) {
  int32_t ret = __wasm_import_udp_method_outgoing_datagram_stream_subscribe((self).__handle);
  return (udp_own_pollable_t) { ret };
}

bool udp_create_socket_create_udp_socket(udp_create_socket_ip_address_family_t address_family, udp_create_socket_own_udp_socket_t *ret, udp_create_socket_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_udp_create_socket_create_udp_socket((int32_t) address_family, ptr);
  udp_create_socket_result_own_udp_socket_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (udp_create_socket_own_udp_socket_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_start_bind(tcp_borrow_tcp_socket_t self, tcp_borrow_network_t network, tcp_ip_socket_address_t *local_address, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t variant;
  int32_t variant1;
  int32_t variant2;
  int32_t variant3;
  int32_t variant4;
  int32_t variant5;
  int32_t variant6;
  int32_t variant7;
  int32_t variant8;
  int32_t variant9;
  int32_t variant10;
  int32_t variant11;
  switch ((int32_t) (*local_address).tag) {
    case 0: {
      const network_ipv4_socket_address_t *payload = &(*local_address).val.ipv4;
      variant = 0;
      variant1 = (int32_t) ((*payload).port);
      variant2 = (int32_t) (((*payload).address).f0);
      variant3 = (int32_t) (((*payload).address).f1);
      variant4 = (int32_t) (((*payload).address).f2);
      variant5 = (int32_t) (((*payload).address).f3);
      variant6 = 0;
      variant7 = 0;
      variant8 = 0;
      variant9 = 0;
      variant10 = 0;
      variant11 = 0;
      break;
    }
    case 1: {
      const network_ipv6_socket_address_t *payload0 = &(*local_address).val.ipv6;
      variant = 1;
      variant1 = (int32_t) ((*payload0).port);
      variant2 = (int32_t) ((*payload0).flow_info);
      variant3 = (int32_t) (((*payload0).address).f0);
      variant4 = (int32_t) (((*payload0).address).f1);
      variant5 = (int32_t) (((*payload0).address).f2);
      variant6 = (int32_t) (((*payload0).address).f3);
      variant7 = (int32_t) (((*payload0).address).f4);
      variant8 = (int32_t) (((*payload0).address).f5);
      variant9 = (int32_t) (((*payload0).address).f6);
      variant10 = (int32_t) (((*payload0).address).f7);
      variant11 = (int32_t) ((*payload0).scope_id);
      break;
    }
  }
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_start_bind((self).__handle, (network).__handle, variant, variant1, variant2, variant3, variant4, variant5, variant6, variant7, variant8, variant9, variant10, variant11, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_finish_bind(tcp_borrow_tcp_socket_t self, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_finish_bind((self).__handle, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_start_connect(tcp_borrow_tcp_socket_t self, tcp_borrow_network_t network, tcp_ip_socket_address_t *remote_address, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t variant;
  int32_t variant1;
  int32_t variant2;
  int32_t variant3;
  int32_t variant4;
  int32_t variant5;
  int32_t variant6;
  int32_t variant7;
  int32_t variant8;
  int32_t variant9;
  int32_t variant10;
  int32_t variant11;
  switch ((int32_t) (*remote_address).tag) {
    case 0: {
      const network_ipv4_socket_address_t *payload = &(*remote_address).val.ipv4;
      variant = 0;
      variant1 = (int32_t) ((*payload).port);
      variant2 = (int32_t) (((*payload).address).f0);
      variant3 = (int32_t) (((*payload).address).f1);
      variant4 = (int32_t) (((*payload).address).f2);
      variant5 = (int32_t) (((*payload).address).f3);
      variant6 = 0;
      variant7 = 0;
      variant8 = 0;
      variant9 = 0;
      variant10 = 0;
      variant11 = 0;
      break;
    }
    case 1: {
      const network_ipv6_socket_address_t *payload0 = &(*remote_address).val.ipv6;
      variant = 1;
      variant1 = (int32_t) ((*payload0).port);
      variant2 = (int32_t) ((*payload0).flow_info);
      variant3 = (int32_t) (((*payload0).address).f0);
      variant4 = (int32_t) (((*payload0).address).f1);
      variant5 = (int32_t) (((*payload0).address).f2);
      variant6 = (int32_t) (((*payload0).address).f3);
      variant7 = (int32_t) (((*payload0).address).f4);
      variant8 = (int32_t) (((*payload0).address).f5);
      variant9 = (int32_t) (((*payload0).address).f6);
      variant10 = (int32_t) (((*payload0).address).f7);
      variant11 = (int32_t) ((*payload0).scope_id);
      break;
    }
  }
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_start_connect((self).__handle, (network).__handle, variant, variant1, variant2, variant3, variant4, variant5, variant6, variant7, variant8, variant9, variant10, variant11, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_finish_connect(tcp_borrow_tcp_socket_t self, tcp_tuple2_own_input_stream_own_output_stream_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[12];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_finish_connect((self).__handle, ptr);
  tcp_result_tuple2_own_input_stream_own_output_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (tcp_tuple2_own_input_stream_own_output_stream_t) {
        (tcp_own_input_stream_t) { *((int32_t*) (ptr + 4)) },
        (tcp_own_output_stream_t) { *((int32_t*) (ptr + 8)) },
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_start_listen(tcp_borrow_tcp_socket_t self, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_start_listen((self).__handle, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_finish_listen(tcp_borrow_tcp_socket_t self, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_finish_listen((self).__handle, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_accept(tcp_borrow_tcp_socket_t self, tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_accept((self).__handle, ptr);
  tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t) {
        (tcp_own_tcp_socket_t) { *((int32_t*) (ptr + 4)) },
        (tcp_own_input_stream_t) { *((int32_t*) (ptr + 8)) },
        (tcp_own_output_stream_t) { *((int32_t*) (ptr + 12)) },
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_local_address(tcp_borrow_tcp_socket_t self, tcp_ip_socket_address_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[36];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_local_address((self).__handle, ptr);
  tcp_result_ip_socket_address_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      network_ip_socket_address_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.ipv4 = (network_ipv4_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (network_ipv4_address_t) {
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 10)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 11)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 12)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 13)))),
            },
          };
          break;
        }
        case 1: {
          variant.val.ipv6 = (network_ipv6_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (uint32_t) (*((int32_t*) (ptr + 12))),
            (network_ipv6_address_t) {
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 16)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 18)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 20)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 22)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 24)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 26)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 28)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 30)))),
            },
            (uint32_t) (*((int32_t*) (ptr + 32))),
          };
          break;
        }
      }
      
      result.val.ok = variant;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_remote_address(tcp_borrow_tcp_socket_t self, tcp_ip_socket_address_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[36];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_remote_address((self).__handle, ptr);
  tcp_result_ip_socket_address_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      network_ip_socket_address_t variant;
      variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
      switch ((int32_t) variant.tag) {
        case 0: {
          variant.val.ipv4 = (network_ipv4_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (network_ipv4_address_t) {
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 10)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 11)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 12)))),
              (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 13)))),
            },
          };
          break;
        }
        case 1: {
          variant.val.ipv6 = (network_ipv6_socket_address_t) {
            (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
            (uint32_t) (*((int32_t*) (ptr + 12))),
            (network_ipv6_address_t) {
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 16)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 18)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 20)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 22)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 24)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 26)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 28)))),
              (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 30)))),
            },
            (uint32_t) (*((int32_t*) (ptr + 32))),
          };
          break;
        }
      }
      
      result.val.ok = variant;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_is_listening(tcp_borrow_tcp_socket_t self) {
  int32_t ret = __wasm_import_tcp_method_tcp_socket_is_listening((self).__handle);
  return ret;
}

tcp_ip_address_family_t tcp_method_tcp_socket_address_family(tcp_borrow_tcp_socket_t self) {
  int32_t ret = __wasm_import_tcp_method_tcp_socket_address_family((self).__handle);
  return ret;
}

bool tcp_method_tcp_socket_ipv6_only(tcp_borrow_tcp_socket_t self, bool *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_ipv6_only((self).__handle, ptr);
  tcp_result_bool_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_ipv6_only(tcp_borrow_tcp_socket_t self, bool value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_ipv6_only((self).__handle, value, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_listen_backlog_size(tcp_borrow_tcp_socket_t self, uint64_t value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_listen_backlog_size((self).__handle, (int64_t) (value), ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_keep_alive_enabled(tcp_borrow_tcp_socket_t self, bool *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_keep_alive_enabled((self).__handle, ptr);
  tcp_result_bool_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_keep_alive_enabled(tcp_borrow_tcp_socket_t self, bool value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_keep_alive_enabled((self).__handle, value, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_keep_alive_idle_time(tcp_borrow_tcp_socket_t self, tcp_duration_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_keep_alive_idle_time((self).__handle, ptr);
  tcp_result_duration_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_keep_alive_idle_time(tcp_borrow_tcp_socket_t self, tcp_duration_t value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_keep_alive_idle_time((self).__handle, (int64_t) (value), ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_keep_alive_interval(tcp_borrow_tcp_socket_t self, tcp_duration_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_keep_alive_interval((self).__handle, ptr);
  tcp_result_duration_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_keep_alive_interval(tcp_borrow_tcp_socket_t self, tcp_duration_t value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_keep_alive_interval((self).__handle, (int64_t) (value), ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_keep_alive_count(tcp_borrow_tcp_socket_t self, uint32_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_keep_alive_count((self).__handle, ptr);
  tcp_result_u32_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint32_t) (*((int32_t*) (ptr + 4)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_keep_alive_count(tcp_borrow_tcp_socket_t self, uint32_t value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_keep_alive_count((self).__handle, (int32_t) (value), ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_hop_limit(tcp_borrow_tcp_socket_t self, uint8_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_hop_limit((self).__handle, ptr);
  tcp_result_u8_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 1))));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_hop_limit(tcp_borrow_tcp_socket_t self, uint8_t value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_hop_limit((self).__handle, (int32_t) (value), ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_receive_buffer_size(tcp_borrow_tcp_socket_t self, uint64_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_receive_buffer_size((self).__handle, ptr);
  tcp_result_u64_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_receive_buffer_size(tcp_borrow_tcp_socket_t self, uint64_t value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_receive_buffer_size((self).__handle, (int64_t) (value), ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_send_buffer_size(tcp_borrow_tcp_socket_t self, uint64_t *ret, tcp_error_code_t *err) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_send_buffer_size((self).__handle, ptr);
  tcp_result_u64_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint64_t) (*((int64_t*) (ptr + 8)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 8)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_method_tcp_socket_set_send_buffer_size(tcp_borrow_tcp_socket_t self, uint64_t value, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_set_send_buffer_size((self).__handle, (int64_t) (value), ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

tcp_own_pollable_t tcp_method_tcp_socket_subscribe(tcp_borrow_tcp_socket_t self) {
  int32_t ret = __wasm_import_tcp_method_tcp_socket_subscribe((self).__handle);
  return (tcp_own_pollable_t) { ret };
}

bool tcp_method_tcp_socket_shutdown(tcp_borrow_tcp_socket_t self, tcp_shutdown_type_t shutdown_type, tcp_error_code_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_method_tcp_socket_shutdown((self).__handle, (int32_t) shutdown_type, ptr);
  tcp_result_void_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 1)));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool tcp_create_socket_create_tcp_socket(tcp_create_socket_ip_address_family_t address_family, tcp_create_socket_own_tcp_socket_t *ret, tcp_create_socket_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_tcp_create_socket_create_tcp_socket((int32_t) address_family, ptr);
  tcp_create_socket_result_own_tcp_socket_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (tcp_create_socket_own_tcp_socket_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool ip_name_lookup_resolve_addresses(ip_name_lookup_borrow_network_t network, preview2_string_t *name, ip_name_lookup_own_resolve_address_stream_t *ret, ip_name_lookup_error_code_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_ip_name_lookup_resolve_addresses((network).__handle, (int32_t) (*name).ptr, (int32_t) (*name).len, ptr);
  ip_name_lookup_result_own_resolve_address_stream_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (ip_name_lookup_own_resolve_address_stream_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 4)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool ip_name_lookup_method_resolve_address_stream_resolve_next_address(ip_name_lookup_borrow_resolve_address_stream_t self, ip_name_lookup_option_ip_address_t *ret, ip_name_lookup_error_code_t *err) {
  __attribute__((__aligned__(2)))
  uint8_t ret_area[22];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_ip_name_lookup_method_resolve_address_stream_resolve_next_address((self).__handle, ptr);
  ip_name_lookup_result_option_ip_address_error_code_t result;
  switch ((int32_t) (*((uint8_t*) (ptr + 0)))) {
    case 0: {
      result.is_err = false;
      ip_name_lookup_option_ip_address_t option;
      switch ((int32_t) (*((uint8_t*) (ptr + 2)))) {
        case 0: {
          option.is_some = false;
          break;
        }
        case 1: {
          option.is_some = true;
          network_ip_address_t variant;
          variant.tag = (int32_t) (*((uint8_t*) (ptr + 4)));
          switch ((int32_t) variant.tag) {
            case 0: {
              variant.val.ipv4 = (network_ipv4_address_t) {
                (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 6)))),
                (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 7)))),
                (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 8)))),
                (uint8_t) ((int32_t) (*((uint8_t*) (ptr + 9)))),
              };
              break;
            }
            case 1: {
              variant.val.ipv6 = (network_ipv6_address_t) {
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 6)))),
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 8)))),
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 10)))),
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 12)))),
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 14)))),
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 16)))),
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 18)))),
                (uint16_t) ((int32_t) (*((uint16_t*) (ptr + 20)))),
              };
              break;
            }
          }
          
          option.val = variant;
          break;
        }
      }
      
      result.val.ok = option;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) (*((uint8_t*) (ptr + 2)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

ip_name_lookup_own_pollable_t ip_name_lookup_method_resolve_address_stream_subscribe(ip_name_lookup_borrow_resolve_address_stream_t self) {
  int32_t ret = __wasm_import_ip_name_lookup_method_resolve_address_stream_subscribe((self).__handle);
  return (ip_name_lookup_own_pollable_t) { ret };
}

void random_get_random_bytes(uint64_t len, preview2_list_u8_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_random_get_random_bytes((int64_t) (len), ptr);
  *ret = (preview2_list_u8_t) { (uint8_t*)(*((int32_t*) (ptr + 0))), (size_t)(*((int32_t*) (ptr + 4))) };
}

uint64_t random_get_random_u64(void) {
  int64_t ret = __wasm_import_random_get_random_u64();
  return (uint64_t) (ret);
}

void random_insecure_get_insecure_random_bytes(uint64_t len, preview2_list_u8_t *ret) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_random_insecure_get_insecure_random_bytes((int64_t) (len), ptr);
  *ret = (preview2_list_u8_t) { (uint8_t*)(*((int32_t*) (ptr + 0))), (size_t)(*((int32_t*) (ptr + 4))) };
}

uint64_t random_insecure_get_insecure_random_u64(void) {
  int64_t ret = __wasm_import_random_insecure_get_insecure_random_u64();
  return (uint64_t) (ret);
}

void random_insecure_seed_insecure_seed(preview2_tuple2_u64_u64_t *ret) {
  __attribute__((__aligned__(8)))
  uint8_t ret_area[16];
  int32_t ptr = (int32_t) &ret_area;
  __wasm_import_random_insecure_seed_insecure_seed(ptr);
  *ret = (preview2_tuple2_u64_u64_t) {
    (uint64_t) (*((int64_t*) (ptr + 0))),
    (uint64_t) (*((int64_t*) (ptr + 8))),
  };
}

extern void __component_type_object_force_link_preview2(void);
void __component_type_object_force_link_preview2_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_preview2();
}
